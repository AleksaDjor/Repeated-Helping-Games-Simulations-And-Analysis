---
title: "main"
author: "Aleksa Đorđević"
date: "2024-04-20"
output: pdf_document
editor_options: 
  markdown: 
    wrap: 72
---
Setting up packages:

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Loading required libraries
library(data.table)
#install.packages("arm")
# library(boot)
library(arm) # used for bayesglm
#install.packages("stringr")
library(stringr) # counting strings
#install.packages("stratEst")
library(stratEst)
#install.packages("caret")
library(caret)
library(dplyr)
#install.packages("ggplot2")
#install.packages("reshape2")
library(ggplot2)
library(reshape2)
```

# Evaluating the performance of behavioral strategy estimation methods in repeated helping games: A Monte Carlo approach

## Simulations

First we need to define the distribution of substrategies for our
population, we do it as such:

```{r}
set.seed(123)

# Defining substrategy probabilities
substrategy_probabilities <- c(ALT = 7/54, #7/54 
                            DEF = 12/54, #12/54
                            REW1 = 6/54, #14/54 /# of all REW substr
                            REW2 = 0, 
                            REW3 = 1/54,
                            SREW = 7/54,
                            CAU0 = 0, #1/54 /# of all CAU substr
                            CAU1 = 0,
                            SCAU = 1/54,
                            CR10 = 0, #5/54 /# of all CR substr
                            CR11 = 0,
                            CR20 = 0,
                            CR21 = 0,
                            CR30 = 0,
                            CR31 = 0,
                            SCR = 5/54,
                            MD10 = 1/54, #4/54 /# of all MD substr
                            MD11 = 0,
                            MD20 = 0,
                            MD21 = 0,
                            MD30 = 0,
                            MD31 = 0,
                            SMD = 2/54,
                            SophCR1 = 0,
                            SophCR2 = 0,
                            SophCR3 = 0,
                            SophCR4 = 0,
                            SophCR5 = 0,
                            SophCR6 = 0,
                            SSophCR = 0,
                            SophMD1 = 0,
                            SophMD2 = 0,
                            SophMD3 = 0,
                            SophMD4 = 0,
                            SophMD5 = 0,
                            SophMD6 = 0,
                            SophMD7 = 0,
                            SophMD8 = 0,
                            SophMD9 = 1/54,
                            SophMD10 = 0,
                            SSophMD = 0,
                            POI = 11/(54*4*3), #11/54 /4 for all PO substr
                            POH = 11/(54*4*3),
                            POL = 11/(54*4*3),
                            RAND = 11/(54*4), #11/54 /4 for RAND substr
                            EXP31 = 11/(54*4*5), #11/54 /4 for all EXP substr
                            EXP32 = 11/(54*4*5),
                            EXP33 = 11/(54*4*5),
                            EXP3S = 11/(54*4*5),
                            ALTERNATE = 11/(54*4), #11/54 /4 for ALTERNATE substr
                            EX1 = 11/(54*4*5))

# checking that they sum up to 1
sum(unname(substrategy_probabilities))
```

After obtaining the distribution of substrategies, we need to form our
experiment groups. We do that by making a function that takes
the probabilities and makes one simulation experiment group of m
people, each substrategy appearing with a probability represented in the
probability distribution presented above.

```{r}
# Defining a function to generate a set of "exp_group_size" players
generate_players <- function(substrategy_probabilities, exp_group_size = 6) {
  
  # In this function we generate our group of "exp_group_size" players randomly, using our distribution of substrategies
  # Its output is a list of m strategies (the base value is 6)
  
  # Extracting strategies and their probabilities
  substrategies <- names(substrategy_probabilities)
  probabilities <- unname(substrategy_probabilities)
  
  # Generating players strategies from the distribution
  players <- sample(substrategies, size = exp_group_size, replace = TRUE, prob = probabilities)
  return(players)
}

```

In the setup, we also need a function that plays each substrategy
correctly. We make a function that takes the name of the substrategy
(character), the round number, the last three actions when the sender was in the role of the
sender and the last three actions of when the receiver (player 2) was in the 
role of the sender - both of these are represented as an integer. In order to 
define the payoff functions we also require the payoff and the initial amount/budget
that each player receives it the start of the game. For experiential substrategies
we also require experience as the input, in the form of a string (e.g. "HPH").

```{r}
# Define a function to determine the action played, depending on the substrategy and information in hand
get_action <- function(substrategy, round, self_history_sum, opp_history_sum, payoff, initial_amount = 3000, experience) {
  
  # This function returns 'H' or 'P' depending on the substrategy selected
  # and all other information the player might have in hand.
  # The shorthand terms for all substrategies are defined in the appendix of the master's thesis.
  
  experience_sum <- str_count(experience, 'H')
  
  if (substrategy == 'ALT') {
    return('H')
  }
  else if (substrategy == 'DEF') {
    return('P')
  } 
  else if (substrategy == 'REW1') {
    if (opp_history_sum >= 1) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'REW2') {
    if (opp_history_sum >= 2) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'REW3') {
    if (opp_history_sum == 3) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'SREW') {
    helping_ratio <- opp_history_sum / 3
    # Choose action with probabilities, 
    # with helping_ratio we play H and with 1 - helping_ratio we play P
    decision <- sample(c('H', 'P'), size = 1, prob = c(helping_ratio, 1 - helping_ratio))
    return(decision)
  }
  else if (substrategy == 'CAU0') {
    if (self_history_sum == 0) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'CAU1') {
    if (self_history_sum <= 1) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'SCAU') {
    helping_ratio <- 1 - (self_history_sum / 2)
    decision <- sample(c('H', 'P'), size = 1, prob = c(helping_ratio, 1 - helping_ratio))
    return(decision)
    }
  else if (substrategy == 'CR10') {
    if (opp_history_sum >= 1 || self_history_sum == 0) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'CR11') {
    if (opp_history_sum >= 1 ||  self_history_sum <= 1) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'CR20') {
    if (opp_history_sum >= 2 ||  self_history_sum == 0) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'CR21') {
    if (opp_history_sum >= 2 ||  self_history_sum <= 1) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'CR30') {
    if (opp_history_sum == 3 ||  self_history_sum == 0) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'CR31') {
    if (opp_history_sum == 3 ||  self_history_sum <= 1) {
      return('H')
    } 
    else {
      return('P')
    }
  }
  else if (substrategy == 'SCR') {
    if (opp_history_sum == 0 &&  self_history_sum == 2) {
      return('P')
    } 
    else if (opp_history_sum == 3 ||  self_history_sum == 0) {
      return('H')
    } 
    else if (opp_history_sum == 0 &&  self_history_sum == 1) {
      helping_p <- 3/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if (opp_history_sum == 1 &&  self_history_sum == 1) {
      helping_p <- 4/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if (opp_history_sum == 1 &&  self_history_sum == 2) {
      helping_p <- 2/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if (opp_history_sum == 2 &&  self_history_sum == 1) {
      helping_p <- 5/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if (opp_history_sum == 2 &&  self_history_sum == 2) {
      helping_p <- 4/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    }
  } 
  else if (substrategy == 'MD10') {
    if (opp_history_sum >= 1 &&  self_history_sum == 0) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'MD11') {
    if (opp_history_sum >= 1 &&  self_history_sum <= 1) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'MD20') {
    if (opp_history_sum >= 2 &&  self_history_sum == 0) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'MD21') {
    if (opp_history_sum >= 2 &&  self_history_sum <= 1) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'MD30') {
    if (opp_history_sum == 3 &&  self_history_sum == 0) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'MD31') {
    if (opp_history_sum == 3 &&  self_history_sum <= 1) {
      return('H')
    } 
    else {
      return('P')
    }
  } 
  else if (substrategy == 'SMD') {
    if (opp_history_sum == 0 ||  self_history_sum == 2) {
      return('P')
    } 
    else if (opp_history_sum == 1 &&  self_history_sum == 0) {
      helping_p <- 2/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if (opp_history_sum == 1 &&  self_history_sum == 1) {
      helping_p <- 1/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if (opp_history_sum == 2 &&  self_history_sum == 0) {
      helping_p <- 4/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if (opp_history_sum == 2 &&  self_history_sum == 1) {
      helping_p <- 2/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if (opp_history_sum == 3 &&  self_history_sum == 0) {
      return('H')
    }
    else if (opp_history_sum == 3 &&  self_history_sum == 1) {
      helping_p <- 3/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    }
  }
  else if (substrategy == 'SophCR1'){
    if ((opp_history_sum >= 1 || ( self_history_sum == 0)) &&  self_history_sum != 2) {
      return('H')
    } 
    else {
      return('P')
    }
  }
  else if (substrategy == 'SophCR2'){
    if ((opp_history_sum >= 2 ||  self_history_sum == 0) &&  self_history_sum != 2) {
      return('H')
    } 
    else {
      return('P')
    }
  }
  else if (substrategy == 'SophCR3'){
    if ((opp_history_sum == 3 ||  self_history_sum == 0) &&  self_history_sum != 2) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophCR4'){
    if ((opp_history_sum >= 1 || ( self_history_sum == 0)) && ( self_history_sum != 2 || opp_history_sum == 3)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophCR5'){
    if ((opp_history_sum >= 2 ||  self_history_sum == 0) && ( self_history_sum != 2 || opp_history_sum == 3)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophCR6'){
    if ((opp_history_sum >= 1 || ( self_history_sum == 0)) && ( self_history_sum != 2 || opp_history_sum == 2 || opp_history_sum == 3)) {
      return('H')
    } 
    else {
      return('P')
    }     
  }
  else if (substrategy == 'SophMD1'){
    if ((opp_history_sum >= 2 &&  self_history_sum == 0) || (opp_history_sum == 3 &&  self_history_sum == 1)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophMD2'){
    if ((opp_history_sum >= 1 &&  self_history_sum == 0) || (opp_history_sum == 3 &&  self_history_sum == 1)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophMD3'){
    if ((opp_history_sum >= 2 &&  self_history_sum == 0) || (opp_history_sum == 3)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophMD4'){
    if ((opp_history_sum >= 1 &&  self_history_sum == 0) || (opp_history_sum == 3)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophMD5'){
    if ((opp_history_sum >= 1 &&  self_history_sum == 0) || (opp_history_sum >= 2 &&  self_history_sum == 1)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophMD6'){
    if (opp_history_sum == 3 || (opp_history_sum == 2 && ( self_history_sum == 0 ||  self_history_sum == 1))){
      return('H')
    }    
    else {
      return('P')
    }
  }
  else if (substrategy == 'SophMD7'){
    if (opp_history_sum == 3 || (opp_history_sum == 2 && ( self_history_sum == 0 ||  self_history_sum == 1)) || (opp_history_sum == 1 &&  self_history_sum == 0)){
      return('H')
    }    
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophMD8'){
    if (opp_history_sum >= 2 || ( self_history_sum == 0 && opp_history_sum != 0)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SophMD9'){
    if ((opp_history_sum >= 1 &&  self_history_sum <= 1) || (opp_history_sum == 3 &&  self_history_sum == 2)) {
      return('H')
    } 
    else {
      return('P')
    }
  }
  else if (substrategy == 'SophMD10'){
    if ((opp_history_sum >= 1 &&  self_history_sum <= 1) || (opp_history_sum == 3 &&  self_history_sum == 2) || (opp_history_sum == 2 &&  self_history_sum == 2)) {
      return('H')
    } 
    else {
      return('P')
    }    
  }
  else if (substrategy == 'SSophCR'){
    if ( self_history_sum == 0 || (self_history_sum == 1 && opp_history_sum == 3) ){
      return('H')
    }
    else if ((opp_history_sum == 1 &&  self_history_sum == 1) || (opp_history_sum == 3 &&  self_history_sum == 2)) {
      helping_p <- 3/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    } 
    else if ((opp_history_sum == 0 &&  self_history_sum == 1) || (opp_history_sum == 0 &&  self_history_sum == 2) || (opp_history_sum == 1 &&  self_history_sum == 2)) {
      return('P')
    }
    else if (opp_history_sum == 2 &&  self_history_sum == 1) {
      helping_p <- 5/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    }
    else if (opp_history_sum == 2 &&  self_history_sum == 2) {
      helping_p <- 1/6
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    }
  }
  else if (substrategy == 'SSophMD'){
    if (( opp_history_sum == 0) || (opp_history_sum == 1 &&  self_history_sum == 2)){
      return('P')
    }
    else if ((opp_history_sum == 1 &&  self_history_sum == 0) || (opp_history_sum == 3 &&  self_history_sum == 2)) {
      helping_p <- 7/10
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    }
    else if ((opp_history_sum == 1 &&  self_history_sum == 1) || (opp_history_sum == 2 &&  self_history_sum == 2)) {
      helping_p <- 2/10
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    }
    else if (opp_history_sum == 2 &&  self_history_sum == 1) {
      helping_p <- 6/10
      return(sample(c('H','P'), size = 1, prob = c(helping_p, 1 - helping_p)))
    }
    else if ((opp_history_sum == 2 &&  self_history_sum == 0) || (opp_history_sum == 3 &&  self_history_sum == 0) || (opp_history_sum == 3 &&  self_history_sum == 1)) {
      return('H')
    }
  }
  else if (substrategy == 'POI'){
   if (payoff >= initial_amount){
     return ('H')
   }
  else {
     return ('P')
    }
  }
  else if (substrategy == 'POH'){
   if (payoff >= initial_amount*1.25){
     return ('H')
   }
  else {
     return ('P')
    }   
  }
  else if (substrategy == 'POL'){
   if (payoff >= initial_amount*0.75){
     return ('H')
   }
  else {
     return ('P')
    }    
  }
  else if (substrategy == 'RAND') {
    return(sample(c('H','P'), size = 1, prob = c(1/2, 1/2)))
  } 
  else if (substrategy == 'EXP31') {
    if (experience_sum >= 1){
      return('H')
    }
    else {
      return('P')
    }
  }
  else if (substrategy == 'EXP32') {
    if (experience_sum >= 2){
      return('H')
    }
    else {
      return('P')
    }
  } 
  else if (substrategy == 'EXP33') {
    if (experience_sum >= 3){
      return('H')
    }
    else {
      return('P')
    }
  } 
  else if (substrategy == 'EXP3S') {
    helping_ratio <- experience_sum / 3
    decision <- sample(c('H', 'P'), size = 1, prob = c(helping_ratio, 1 - helping_ratio))
    return(decision)
  }
  else if (substrategy == "ALTERNATE"){
    if (round %% 2 == 0) {
        return("H") 
      } else {
        return("P")
      }
  }
  else if (substrategy == "EX1"){
    if (substr(experience, nchar(experience), nchar(experience)) == 'H'){
      return('H')
    }
    else {
      return('P')
    }    
  }
}

```

This is the main function of the simulation.

It takes the number of players (usually we will use 6), the number of
rounds of the simulation (usually we will use 100), the distribution of
substrategies, the sender's and receiver's payoff when help is selected,
the starting budget of each player and the error rate of the simulation.

It will return a data frame of the form: 

- round number 
- the id of the first player (sender) 
- the id of the second player (receiver) 
- the substrategy of the first player (in the form of a string/character) 
- the action the first player makes (H - help or P - pass) (in the form of
a string/character) 
- the last 3 actions played when the player 1 was the sender 
(in the form of a string/character) 
- the last 3 actions played when the player 2 was the sender (in the form of a
string/character) 
- player 1's current budget 
- player 2's current budget 
- the last 3 actions played against player 1 
- the number of helps from the last 2 actions played when the player 1 was 
the sender 
- the number of helps from the last 3 actions played when the player 2 was
the sender

```{r}
simulate <- function(num_players = 6, num_rounds = 100, substrategy_probabilities, sender_payoff = 150, receiver_payoff = 250, starting_money = 3000, error_rate = 0.05) {
  
  #The main function that simulates the whole game.
  #It returns a table of the form:
  #[round, player1_id, player2_id, player_1_substrategy, player_1_history, player_2_history, player_1_payoff, player_2_payoff, exp_history] for each game played among the pairs
  
  # We generate our substrategies
  substrategies <- generate_players(substrategy_probabilities, num_players)

  # Generating the main database table
  table <- data.frame(round = integer(),
                      player1_id = integer(),
                      player2_id = integer(),
                      player1_substrategy = character(),
                      player1_action_played = character(),
                      player1_history = list(),
                      player2_history = list(),
                      player1_payoff = integer(),
                      player2_payoff = integer(),
                      exp_history = list(),
                      player1_history_sum = integer(),
                      player2_history_sum = integer()
                      )
  
  # We set up a data frame for players payoffs
  player_names <- as.character(1:num_players)
  money_vector <- rep(starting_money, num_players)

  # We create the data frame
  payoffs <- as.data.frame(t(money_vector))
  
  # Changing the name of the columns to '1','2','3',...
  colnames(payoffs) <- player_names

  # Making a list for player experience, everybody starts with a random experience
  # player experience is a random collection of 'H' and 'P'
  # both of which appear with a probability 50% for each move
  experiential_history <- lapply(1:num_players, function(x) {
    paste(sample(c('H', 'P'), size = 3, replace = TRUE), collapse = "")
  })

  # We define a history function for all of the players, 
  # starting history is a random collection of 'H' and 'P'
  # both of which appear with a probability 50% for each move
  player_history <- lapply(1:num_players, function(x) {
    paste(sample(c('H', 'P'), size = 3, replace = TRUE), collapse = "")
  })

  for (round_number in 1:num_rounds) {
    # Generate a random permutation of players
    player_order <- sample(num_players)
    
    # Split the players into num_players/2 pairs
    pairs <- matrix(player_order, ncol = 2, byrow = TRUE)
    
    # Doing a for loop for all pairs for this round
    for (i in 1:nrow(pairs)) {
      pair <- pairs[i,]

      player1 <- pair[1]
      player2 <- pair[2]
      
      # We add player1 and player2 history as integers, only looking at the last two moves for player 1
      num_self_history <- str_count(substr(player_history[[player1]], nchar(player_history[[player1]]) - 1, nchar(player_history[[player1]])), 'H')
      num_opp_history <- str_count(player_history[[player2]], 'H')
      
      # We define the action that player 1 plays if there is no error rate
      action_played_no_error <- get_action(substrategies[player1], round = round_number, num_self_history, num_opp_history, payoffs[[player1]], initial_amount = starting_money, experience = experiential_history[[player1]])

      # We define the action that player 1 plays having in mind the error rate
      # We comment this out if we don't use error rates, change name of action_played_no_error to action_played
      if (action_played_no_error == 'H') {
        action_played <- sample(c(action_played_no_error, 'P'), size = 1, prob = c(1 - error_rate, error_rate))
      } else {
        action_played <- sample(c(action_played_no_error, 'H'), size = 1, prob = c(1 - error_rate, error_rate))
      }
      
      # # Fixing that players can't have a payoff < 0 
      # if (action_played == 'H' && payoffs[[player1]] < sender_payoff) {
      #   action_played <- 'P'
      # }
      
      # We add all of the info to the table
      row_data <- data.frame(round = round_number,
                             player1_id = player1,
                             player2_id = player2,
                             player1_substrategy = substrategies[player1],
                             player1_action_played = action_played,
                             player1_history = player_history[[player1]],
                             player2_history = player_history[[player2]],
                             player1_payoff = payoffs[[player1]],
                             player2_payoff = payoffs[[player2]],
                             exp_history = experiential_history[[player1]],
                             player1_history_sum = num_self_history,
                             player2_history_sum = num_opp_history
                             )

      # We add the new data to the table
      table <- rbind(table, row_data)      
      
      # We update the payoff of each player
      if (action_played == 'H'){
          payoffs[[player1]] <- payoffs[[player1]] - sender_payoff
          payoffs[[player2]] <- payoffs[[player2]] + receiver_payoff
      }
      
      
      # We make a function to update the histories (player history, experiential history)
      update_history <- function(history, action) {
        updated_history <- substr(history, nchar(history) - 1, nchar(history))  # Remove the first character
        updated_history <- paste0(updated_history, action)  # Append the new action
        return(updated_history)
      }
      
      # We update the player history
      player_history[[player1]] <- update_history(player_history[[player1]], action_played)
      
      # We update the experiential history
      experiential_history[[player2]] <- update_history(experiential_history[[player2]], action_played)      
      
    }
  }
  return(table)
}

```

Forming the simulation data - a list of simulations which can be accessed by
simulation_list[[n]]:

```{r}
simulate_data <- function(num_simulations, num_players = 6, num_rounds = 100, substrategy_probabilities, sender_payoff = 150, receiver_payoff = 250, starting_money = 3000, error_rate = 0.05){
  # Create an empty list to store simulation results
  simulation_list <- list()
  
  # Measure the start time
  start_time <- Sys.time()
  
  # Loop from 1 to num_simulations and populate simulation_list
  for (i in 1:num_simulations) {
    print(paste("simulation number", i))
    # Call simulate function and store the result in the list
    simulation_list[[i]] <- simulate(num_players, num_rounds, substrategy_probabilities, sender_payoff, receiver_payoff, starting_money, error_rate)
  }
  
  # Measure the end time
  end_time <- Sys.time()
  
  # Calculate the run time
  runtime <- end_time - start_time
  print(runtime)
  return(simulation_list)
}

```

## Estimation methods

### DFIT estimation method

The first of the estimation methods is conceptually the most simple.

It takes all of the actions played by each player during all of the
rounds and going through each substrategy sees which substrategies
actions match the most with the played actions.

We first need a function that gives us which substrategy fits into which
strategy in order to test the accuracy of the estimation method.

```{r}
get_strategy <- function(substrategy){
    # Finding the matching strategy
    if (substrategy %in% c('REW1', 'REW2', 'REW3', 'SREW')){
      return('REW')
    }
    else if(substrategy %in% c('CAU0', 'CAU1', 'SCAU')){
      return('CAU')
    }
    else if(substrategy %in% c('CR10', 'CR11', 'CR20', 'CR21', 'CR30', 'CR31', 'SCR', 'SophCR1', 'SophCR2', 'SophCR3', 'SophCR4', 'SophCR5', 'SophCR6', 'SSophCR', 'SOPHCR1', 'SOPHCR2', 'SOPHCR3', 'SOPHCR4', 'SOPHCR5', 'SOPHCR6', 'SSOPHCR')){
      return('CR')
    }
    else if(substrategy %in% c('MD10', 'MD11', 'MD20', 'MD21', 'MD30', 'MD31', 'SMD', 'SophMD1', 'SophMD2', 'SophMD3', 'SophMD4', 'SophMD5', 'SophMD6', 'SophMD7','SophMD8', 'SophMD9', 'SophMD10', 'SSophMD', 'SOPHMD1', 'SOPHMD2', 'SOPHMD3', 'SOPHMD4', 'SOPHMD5', 'SOPHMD6', 'SOPHMD7','SOPHMD8', 'SOPHMD9', 'SOPHMD10', 'SSOPHMD')){
      return('MD')
    }
    else if(substrategy == 'ALT'){
      return('ALT')
    }
    else if(substrategy == 'DEF'){
      return('DEF')
    }
    else{
      return('UCL')
    }
}
```

The estimation methods input is one simulation of m people (can be any number
but as we said, we will take 6 players being the standard), and
it's output is two data frames.

The first data frame consists of: 
- the id of the player 
- the substrategy played by the player 
- the substrategy assigned by DFIT 
- the strategy played by the player 
- the strategy assigned by DFIT 
- the matching rate of the assigned substrategy

The second data frame consists of: 
- the average matching of all 6 assigned substrategies for all of the players 
- the number of substrategies correctly assigned

```{r}
DFIT_classifier <- function(simulation) {
  
  # Initialize main data frame for this simulation
  table <- data.frame(
                    player1_id = integer(),
                    player_1_substrategy = character(),
                    player_1_predicted_substrategy = character(),
                    max_p1_success_rate = integer())
  
  # Initialize the stats table for this simulation, it consists of:
  # - how many strategies are correctly fitted out of 6
  # - what is the average overlap with played strategies
  stats_table <- data.frame(
                          overlap_ratio = integer(),
                          num_matching_strategies = integer()
  )
  counter_of_matching_strategies <- 0
  overlap_ratio_list <- numeric()
  
  # Iterate over each player from 1 to num of players
  for (player_id in 1:num_players) {
    player_ID_table <- list()  # Initialize player ID table for this player
    
    # Initialize substrategy table for this player
    substrategy_table <- c(ALT = 0, DEF = 0, REW1 = 0, 
                        REW2 = 0, REW3 = 0, CAU0 = 0, CAU1 = 0, CR10 = 0, CR11 = 0, 
                        CR20 = 0, CR21 = 0, CR30 = 0, CR31 = 0,  MD10 = 0, MD11 = 0, MD20 = 0, 
                        MD21 = 0, MD30 = 0, MD31 = 0, SophCR1 = 0, SophCR2 = 0, SophCR3 = 0, 
                        SophCR4 = 0, SophCR5 = 0, SophCR6 = 0, SophMD1 = 0, 
                        SophMD2 = 0, SophMD3 = 0, SophMD4 = 0, SophMD5 = 0, SophMD6 = 0, 
                        SophMD7 = 0,SophMD8 = 0, SophMD9 = 0, SophMD10 = 0) # this will show us what is the overlap of a certain substrategy with the played moves
    
    # Iterate over strategies
    for (substrategy in names(substrategy_table)) {
      # Iterate over rounds where player_ID is correct
      # Initialize counters
      counter <- 0
      counter_how_many_moves_does_he_play <- 0
      for (round_data in 1:nrow(simulation)) {
        # player_id check
        if (player_id == simulation[round_data, "player1_id"]) {
          counter_how_many_moves_does_he_play <- counter_how_many_moves_does_he_play + 1
          # Save his played substrategy in a variable
          round_number <- simulation[round_data, "round"]
          played_substrategy <- simulation[round_data, "player1_substrategy"]
          move_played <- simulation[round_data, "player1_action_played"]
          # We have to put both histories as lists as they are strings in the simulation output
          self_history_sum <- simulation[round_data, "player1_history_sum"]
          opp_history_sum <- simulation[round_data, "player2_history_sum"]
          payoff <- simulation[round_data, "player1_payoff"]
          initial_amount <- starting_money
          experience <- simulation[round_data, "exp_history"]
          # Check if substrategy matches and update counter
          if (get_action(substrategy, round_number, self_history_sum, opp_history_sum, payoff, initial_amount, experience) == move_played) {
            # counter is incremented if he plays the same move as the substrategy in the for loop
            counter <- counter + 1
          }
        }   
      }
      
      # Calculate success rate for the substrategy
      success_rate <- round(counter / counter_how_many_moves_does_he_play, 4)
      substrategy_table[substrategy] <- success_rate
    }
    # Finding the substrategy with the maximal overlap
    max_substrategy <- names(substrategy_table)[which.max(substrategy_table)]
    max_success_rate <- substrategy_table[max_substrategy]
    
    if (max_success_rate < 0.7) {
      # We add all of the info to the table
      row_data <- data.frame(
                             player1_id = player_id,
                             player1_substrategy = played_substrategy,
                             player1_predicted_substrategy = 'UCL',
                             player1_strategy = get_strategy(played_substrategy),
                             player1_predicted_strategy = 'UCL',
                             max_p1_success_rate = max_success_rate)
      # We add the new data to the table
      table <- rbind(table, row_data)
      if (get_strategy(played_substrategy) == 'UCL'){
        counter_of_matching_strategies <- counter_of_matching_strategies + 1
      }
    } else {
      # We add all of the info to the table
      row_data <- data.frame(
                             player1_id = player_id,
                             player1_substrategy = played_substrategy,
                             player1_predicted_substrategy = max_substrategy,
                             player1_strategy = get_strategy(played_substrategy),
                             player1_predicted_strategy = get_strategy(max_substrategy),
                             max_p1_success_rate = max_success_rate)
      # We add the new data to the table
      table <- rbind(table, row_data)
      if (get_strategy(played_substrategy) == get_strategy(max_substrategy)){
        counter_of_matching_strategies <- counter_of_matching_strategies + 1
      }
    }
    # adding the overlap ratio of the most overlapping substrategy
    overlap_ratio_list <- c(overlap_ratio_list, max_success_rate)
}  
  
  # updating the stats table
  average_overlap_ratio <- round(sum(overlap_ratio_list) / length(overlap_ratio_list), 4)
  stats_row_data <- data.frame(
                              overlap_ratio = average_overlap_ratio,
                              num_matching_strategies = counter_of_matching_strategies
  )
  stats_table <- rbind(stats_table, stats_row_data)
  
  return(list(table,stats_table))
}

```

### SFIT estimation method

The second of the estimation methods is done with a logit regression with some
additional rules regarding the estimation.

First, we need to modify our function get_strategy in order to correctly
evaluate the accuracy of this classifier. Now cautious rewarders are a
part of the rewarder strategy profile and mild defectors are a part of
the cautious strategy profile.

```{r}
get_strategy_SFIT <- function(substrategy){
    # Finding the matching strategy
    if (substrategy %in% c('REW1', 'REW2', 'REW3', 'SREW','CR10', 'CR11', 'CR20', 'CR21', 'CR30', 'CR31', 'SCR', 'SophCR1', 'SophCR2', 'SophCR3', 'SophCR4', 'SophCR5', 'SophCR6', 'SSophCR')){
      return('REW')
    }
    else if(substrategy %in% c('CAU0', 'CAU1', 'SCAU','MD10', 'MD11', 'MD20', 'MD21', 'MD30', 'MD31', 'SMD', 'SophMD1', 'SophMD2', 'SophMD3', 'SophMD4', 'SophMD5', 'SophMD6', 'SophMD7','SophMD8', 'SophMD9', 'SophMD10', 'SSophMD')){
      return('CAU')
    }
    else if(substrategy == 'ALT'){
      return('ALT')
    }
    else if(substrategy == 'DEF'){
      return('DEF')
    }
    else{
      return('UCL')
    }
}

```

The estimation method takes all of the actions played by each player during all
of the rounds and does a logit regression where the dependent variable
is the action played and the independent variables are his last 3 played
actions and the receivers last 3 played actions.

It's input is a simulation consisting of m players during their game of
n rounds.

The output consists of a data frame with the following items: 
- the id of player 1 
- the substrategy of player 1 (sender's substrategy)
- the strategy of player 1 
- the strategy of player 1 predicted by SFIT 
- helping rate of player 1 (the percentage amount of helps during his
play)

```{r}
SFIT_classifier <- function(simulation) {
  
  # Initialize main data frame for this simulation
  table <- data.frame(
    player1_id = integer(),
    player1_substrategy = character(),
    player1_predicted_strategy = character(),
    player1_strategy = character(),
    helping_rate = integer())
  
  counter_of_matching_strategies <- 0
  
  stats_table <- data.frame(
                          num_matching_strategies = integer()
  )
  
  
  # Iterate over each player from 1 to num players
  for (player_id in 1:num_players) {
    # making the data frame for each player
    player_ID_table <- data.frame(
      move_played = character(),
      num_self_history = integer(), 
      num_opp_history = integer(), 
      played_substrategy = character())
    
    helping_rate_counter <- 0
    move_counter <- 0
    # iterate through all rows in our simulation
    for (round_data in 1:nrow(simulation)) {
      # player_id check
      if (player_id == simulation[round_data, "player1_id"]) {
        # Save his played substrategy and other info in variables
        played_substrategy <- simulation[round_data, "player1_substrategy"]
        move_played <- simulation[round_data, "player1_action_played"]
        self_history <- simulation[round_data, "player1_history"]
        opp_history <- simulation[round_data, "player2_history"]
        num_self_history <- simulation[round_data, "player1_history_sum"]
        num_opp_history <- simulation[round_data, "player2_history_sum"]
        # Check if substrategy matches and update counter
        move_counter <- move_counter + 1
        if ('H' == move_played) {
          helping_rate_counter <- helping_rate_counter + 1
          # we change the moves to ints here for our logistic regression
          move_played <- 1
        } else {
          move_played <- 0
        } 
        
        # this is the data for each player, further used in the log regression
        row_data <- data.frame(
          move_played = move_played,
          num_self_history = num_self_history, 
          num_opp_history = num_opp_history, 
          played_substrategy = played_substrategy)
        
        player_ID_table <- rbind(player_ID_table, row_data)
      }
    }
    helping_rate <- round(helping_rate_counter / move_counter, 4)
    
    # getting the independent and dependent variables
    Y <- player_ID_table[, "move_played"]
    X1 <- player_ID_table[, "num_opp_history"]
    X2 <- player_ID_table[, "num_self_history"]
    
    res<-summary(glm(Y~X1, family="binomial"))
    st.errors<-coef(res)[, 2]
    # If we have linear separation:
    if(any(st.errors>500) || nrow(coef(res)) == 1){
      res<-summary(bayesglm(Y~X1,family=binomial))
    }
    
    #based on: 
    #https://stats.stackexchange.com/questions/325354/if-and-how-to-use-one-tailed-testing-in-multiple-regression
    z<-coef(res)[2, 3] #izberes z-vrednost pri parBlue
    # 2*pnorm(-abs(z),0,1) #two-tail for H1: beta=!0
    opp_history_p_value_fit<-pnorm(z,0,1,lower.tail=F) #one-tail for H1: beta>0; we want that for rewarders
    # pnorm(z,0,1,lower.tail=T) #one-tail for H1: beta<0; we want that for cautious
    
    opp_history_coef_fit<-coef(res)[2, 1]
    
    if (helping_rate >= 0.4 && opp_history_p_value_fit <= 0.05 && opp_history_coef_fit > 0){
      row_data <- data.frame(
        player1_id = player_id,
        player1_substrategy = played_substrategy,
        player1_strategy = get_strategy_SFIT(played_substrategy),
        player1_predicted_strategy = 'REW',
        helping_rate = helping_rate)
      
      table <- rbind(table, row_data)
    } else {
          # We form a new model using both self and opponent history
          res2<-summary(glm(Y~X1+X2, family="binomial"))
      
          st.errors2<-coef(res2)[2,]
          
          #ce imas linear separation problem, naredis:
          # we have added nrow(coef(res2)) == 2 as in some cases (ALT), we have
          # too much correlation but still any(st.errors2 is less than 500
          if(any(st.errors2>500) || nrow(coef(res2)) == 2){
            res2<-summary(bayesglm(Y~X1+X2,family=binomial))
          }
          
          z2<-coef(res2)[2:3, 3] #izberes z-vrednost pri parBlue in numBlue2Last
          opp_history_p_value<-pnorm(z2[1],0,1,lower.tail=F) #one-tail for H1: beta>0; we want that for rewarders
          self_history_p_value<-pnorm(z2[2],0,1,lower.tail=T) #one-tail for H1: beta<0; we want that for cautious
      
      
          opp_history_coef<-coef(res2)[2, 1]
          self_history_coef<-coef(res2)[3, 1]
      
          if(helping_rate >= 0.15 && helping_rate <= 0.85 && self_history_p_value <= 0.05 && self_history_coef < 0){
            row_data <- data.frame(
              player1_id = player_id,
              player1_substrategy = played_substrategy,
              player1_strategy = get_strategy_SFIT(played_substrategy),
              player1_predicted_strategy = 'CAU',
              helping_rate = helping_rate)
          
            table <- rbind(table, row_data)
          } else if (helping_rate <= 0.2){
              row_data <- data.frame(
                player1_id = player_id,
                player1_substrategy = played_substrategy,
                player1_strategy = get_strategy_SFIT(played_substrategy),
                player1_predicted_strategy = 'DEF',
                helping_rate = helping_rate)
        
              table <- rbind(table, row_data)
          } else if(helping_rate >= 0.8){
              row_data <- data.frame(
                player1_id = player_id,
                player1_substrategy = played_substrategy,
                player1_strategy = get_strategy_SFIT(played_substrategy),
                player1_predicted_strategy = 'ALT',
                helping_rate = helping_rate)
              
              table <- rbind(table, row_data)
          } else{
              row_data <- data.frame(
                player1_id = player_id,
                player1_substrategy = played_substrategy,
                player1_strategy = get_strategy_SFIT(played_substrategy),
                player1_predicted_strategy = 'UCL',
                helping_rate = helping_rate)
                
              table <- rbind(table, row_data)
          }
    }
    
    # counting how many strategies are predicted correctly
    if (get_strategy_SFIT(played_substrategy) == row_data["player1_predicted_strategy"]){
        counter_of_matching_strategies <- counter_of_matching_strategies + 1
    }
  }
  
  stats_row_data <- data.frame(
                            num_matching_strategies = counter_of_matching_strategies
  )
  stats_table <- rbind(stats_table, stats_row_data)
  
  
  return(list(table, stats_table))    
}

```

### TREND estimation method

The third of the estimation methods is done with a logit regression with some
additional rules regarding the estimation, it is done in a similar
was as SFIT, except we only do one logit regression and we use different
rules to classify players.

Once again, we need to change the get_strategy function in order to
correctly evaluate the accuracy of the classifier.

```{r}
get_strategy_TREND <- function(substrategy){
    # Finding the matching strategy
    if (substrategy %in% c('REW1', 'REW2', 'REW3', 'SREW')){
      return('REW')
    }
    else if(substrategy %in% c('CAU0', 'CAU1', 'SCAU')){
      return('CAU')
    }
    else if(substrategy %in% c('CR10', 'CR11', 'CR20', 'CR21', 'CR30', 'CR31', 'SCR', 'SophCR1', 'SophCR2', 'SophCR3', 'SophCR4', 'SophCR5', 'SophCR6', 'SSophCR','MD10', 'MD11', 'MD20', 'MD21', 'MD30', 'MD31', 'SMD', 'SophMD1', 'SophMD2', 'SophMD3', 'SophMD4', 'SophMD5', 'SophMD6', 'SophMD7','SophMD8', 'SophMD9', 'SophMD10', 'SSophMD')){
      return('SOPH')
    }
    else if(substrategy == 'ALT'){
      return('ALT')
    }
    else if(substrategy == 'DEF'){
      return('DEF')
    }
    else{
      return('UCL')
    }
}
```

The estimation method takes all of the actions played by each player during all
of the rounds and does a logit regression where the dependent variable
is the action played and the independent variables are his last 3 played
actions, the receivers last 3 played actions and the round number.

It's input is a simulation consisting of m players during their game of
n rounds.

The output consists of a data frame with the following items: 
- the id of player 1 
- the substrategy of player 1 (sender's substrategy) 
- the strategy of player 1 
- the substrategy of player 1 predicted by TREND 
- helping rate of player 1 (the percentage amount of helps during his
play)

```{r}
TREND_classifier <- function(simulation) {
  counter_of_matching_strategies <- 0
  
  stats_table <- data.frame(
                          num_matching_strategies = integer()
  )
  # Initialize main data frame for this simulation
  table <- data.frame(
    player1_id = integer(),
    player1_substrategy = character(),
    player1_strategy = character(),
    player1_predicted_strategy = character(),
    helping_rate = integer())
  
  # Iterate over each player from 1 to num_players
  for (player_id in 1:num_players) {
    player_ID_table <- data.frame(
      move_played = character(),
      num_self_history = integer(), 
      num_opp_history = integer(), 
      round_number = integer(),
      played_substrategy = character())
    
    helping_rate_counter <- 0
    move_counter <- 0
    # iterate through all rows in our simulation
    for (round_data in 1:nrow(simulation)) {
      # player_id check
      if (player_id == simulation[round_data, "player1_id"]) {
        # Save his played substrategy and other info in a variable
        round_number = simulation[round_data, "round"]
        played_substrategy <- simulation[round_data, "player1_substrategy"]
        move_played <- simulation[round_data, "player1_action_played"]
        self_history <- simulation[round_data, "player1_history"]
        opp_history <- simulation[round_data, "player2_history"]
        num_self_history <- simulation[round_data, "player1_history_sum"]
        num_opp_history <- simulation[round_data, "player2_history_sum"]
        # Check if substrategy matches and update counter
        move_counter <- move_counter + 1
        if ('H' == move_played) {
          helping_rate_counter <- helping_rate_counter + 1
          # we change the moves to ints here for our logistic regression
          move_played <- 1
        } else {
          move_played <- 0
        } 
        
        # this is the data for each player, further used in the log regression
        row_data <- data.frame(
          round_number = round_number,
          move_played = move_played,
          num_self_history = num_self_history, 
          num_opp_history = num_opp_history, 
          played_substrategy = played_substrategy)
        
        player_ID_table <- rbind(player_ID_table, row_data)
      }
    }
    helping_rate <- round(helping_rate_counter / move_counter, 4)
    
    # getting the independent and dependent variables
    Y <- player_ID_table[, "move_played"]
    X1 <- player_ID_table[, "num_opp_history"]
    X2 <- player_ID_table[, "num_self_history"]
    X3 <- player_ID_table[, "round_number"]
    
    res2<-summary(glm(Y~X1+X2+X3, family="binomial"))
    
    st.errors2<-coef(res2)[, 2]
    # If we have linear separation:
    # we have added nrow(coef(res2)) == 2 as in some cases (ALT), we have
    # too much correlation but still any(st.errors2 is less than 500
    if(any(st.errors2>500) || nrow(coef(res2)) == 2){
      res2<-summary(bayesglm(Y~X1+X2+X3,family=binomial))
    }
    
    
    z2<-coef(res2)[2:3, 3] #you choose a z-value
    opp_history_p_value<-pnorm(z2[1],0,1,lower.tail=F) #one-tail for H1: beta>0; we want that for rewarders
    self_history_p_value<-pnorm(z2[2],0,1,lower.tail=T) #one-tail for H1: beta<0; we want that for cautious
    
    opp_history_coef<-coef(res2)[2, 1]
    self_history_coef<-coef(res2)[3, 1]
    
    if (opp_history_p_value <= 0.05 && opp_history_coef > 0 && self_history_p_value <= 0.05 && self_history_coef < 0){
      row_data <- data.frame(
        player1_id = player_id,
        player1_substrategy = played_substrategy,
        player1_strategy = get_strategy_TREND(played_substrategy),
        player1_predicted_strategy = 'SOPH',
        helping_rate = helping_rate)
      
      table <- rbind(table, row_data)
    } else {
          # We form a new model using both self and opponent history
          if(opp_history_p_value <= 0.05 && opp_history_coef > 0){
            row_data <- data.frame(
              player1_id = player_id,
              player1_substrategy = played_substrategy,
              player1_strategy = get_strategy_TREND(played_substrategy),
              player1_predicted_strategy = 'REW',
              helping_rate = helping_rate)
        
            table <- rbind(table, row_data)
          } else if (self_history_p_value <= 0.05 && self_history_coef < 0){
              row_data <- data.frame(
                player1_id = player_id,
                player1_substrategy = played_substrategy,
                player1_strategy = get_strategy_TREND(played_substrategy),
                player1_predicted_strategy = 'CAU',
                helping_rate = helping_rate)
        
              table <- rbind(table, row_data)
          } else if (helping_rate <= 0.1){
            row_data <- data.frame(
              player1_id = player_id,
              player1_substrategy = played_substrategy,
              player1_strategy = get_strategy_TREND(played_substrategy),
              player1_predicted_strategy = 'DEF',
              helping_rate = helping_rate)
            
            table <- rbind(table, row_data)
          } else if(helping_rate >= 0.9){
              row_data <- data.frame(
                player1_id = player_id,
                player1_substrategy = played_substrategy,
                player1_strategy = get_strategy_TREND(played_substrategy),
                player1_predicted_strategy = 'ALT',
                helping_rate = helping_rate)
        
              table <- rbind(table, row_data)
          } else{
                  row_data <- data.frame(
                  player1_id = player_id,
                  player1_substrategy = played_substrategy,
                  player1_strategy = get_strategy_TREND(played_substrategy),
                  player1_predicted_strategy = 'UCL',
                  helping_rate = helping_rate)
        
                  table <- rbind(table, row_data)
          }
    }  
    # counting how many strategies are predicted correctly
    if (get_strategy_TREND(played_substrategy) == row_data["player1_predicted_strategy"]){
        counter_of_matching_strategies <- counter_of_matching_strategies + 1
    }
  }
  stats_row_data <- data.frame(
                            num_matching_strategies = counter_of_matching_strategies
  )
  stats_table <- rbind(stats_table, stats_row_data)
  
  return(list(table, stats_table)) 
}

```

### MLFIT estimation method

Before forming the estimation method, we need to initialize all substrategies:

```{r}
# For defining the substrategies, we need their inputs and probabilties

inp<-c("00","01","02","03","10","11","12","13","20","21","22","23") #all possible combinations of OwnRep and OthRep
prob.ch<-c(1,0,0,1) #probabilities of H and P in state 1 and probabilities H and P in state 2

# We define all substrategies

REW1 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=rep(c(2,1,1,1),3))
REW2 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=rep(c(2,2,1,1),3))
REW3 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=rep(c(2,2,2,1),3))
CAU0 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),rep(2,8)))
CAU1 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,8),rep(2,4)))
DEF = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=1, prob.choices=c(0,1),tr.inputs=rep(1,12))
ALT = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=1, prob.choices=c(1,0),tr.inputs=rep(1,12))
MD10 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,1,1,1,rep(2,8)))
MD11 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(c(2,1,1,1),2),rep(2,4)))
MD20 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,2,1,1,rep(2,8)))
MD21 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(c(2,2,1,1),2),rep(2,4)))
MD30 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,2,2,1,rep(2,8)))
MD31 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(c(2,2,2,1),2),rep(2,4)))
CR10 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),rep(c(2,1,1,1),2)))
CR11 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,8),rep(c(2,1,1,1),1)))
CR20 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),rep(c(2,2,1,1),2)))
CR21 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,8),rep(c(2,2,1,1),1)))
CR30 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),rep(c(2,2,2,1),2)))
CR31 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,8),rep(c(2,2,2,1),1)))
RAND = stratEst.strategy(choices=c("H","P"),inputs=inp, num.states=1, prob.choices=c(1/2,1/2))

SREW = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=4,prob.choices=c(1,0,2/3,1/3,1/3,2/3,0,1),tr.inputs=c(rep(c(4,3,2,1),3)))
SCAU = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=3,prob.choices=c(1,0,0.5,0.5,0,1), tr.inputs=c(rep(1,4),rep(2,4),rep(3,4)))
SMD = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=6,prob.choices=c(1,0,2/3,1/3,1/2,1/2,1/3,2/3,1/6,5/6,0,1),tr.inputs=c(6,4,2,1,6,5,4,3,6,6,6,6))
SCR = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=6,prob.choices=c(1,0,5/6,1/6,2/3,1/3,1/2,1/2,1/3,2/3,0,1),tr.inputs=c(1,1,1,1,4,3,2,1,6,5,3,1))

#additional sophisticated strategies
SOPHCR1 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),c(2,1,1,1,2,2,2,2)))
SOPHCR2 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),c(2,2,1,1,2,2,2,2)))
SOPHCR3 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),c(2,2,2,1,2,2,2,2)))
SOPHCR4 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),c(2,1,1,1,2,2,2,1)))
SOPHCR5 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),c(2,2,1,1,2,2,2,1)))
SOPHCR6 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(rep(1,4),c(2,1,1,1,2,2,1,1)))

SOPHMD1 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,2,1,1,2,2,2,1,rep(2,4)))
SOPHMD2 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,1,1,1,2,2,2,1,rep(2,4)))
SOPHMD3 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,2,1,1,2,2,2,1,2,2,2,1))
SOPHMD4 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,1,1,1,2,2,2,1,2,2,2,1))
SOPHMD5 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,1,1,1,2,2,1,1,rep(2,4)))
SOPHMD6 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,2,1,1,2,2,1,1,2,2,2,1))
SOPHMD7 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,1,1,1,2,2,1,1,2,2,2,1))
SOPHMD8 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,1,1,1,2,2,1,1,2,2,1,1))
SOPHMD9 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,1,1,1,2,1,1,1,2,2,2,1))
SOPHMD10 = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=2, prob.choices=prob.ch, tr.inputs=c(2,1,1,1,2,1,1,1,2,2,1,1))

SSOPHCR = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=5,prob.choices=c(1,0,5/6,1/6,1/2,1/2,1/6,5/6,0,1),tr.inputs=c(1,1,1,1,5,3,2,1,5,5,4,3))
SSOPHMD = stratEst.strategy(choices=c("H","P"), inputs=inp, num.states=5,prob.choices=c(1,0,7/10,3/10,6/10,4/10,2/10,8/10,0,1),tr.inputs=c(5,2,1,1,5,4,3,1,5,5,4,2))

# Defining the list of strategies

strathr=list("DEF"=DEF, "ALT"=ALT,"REW1"=REW1,"REW2"=REW2,"REW3"=REW3,"SREW"=SREW,"CAU0"=CAU0, "CAU1"=CAU1,"SCAU"=SCAU,"CR10"=CR10,"CR11"=CR11,"CR20"=CR20,"CR21"=CR21,"CR30"=CR30,"CR31"=CR31,"SCR"=SCR,"MD10"=MD10,"MD11"=MD11,"MD20"=MD20,"MD21"=MD21,"MD30"=MD30,"MD31"=MD31,"SMD"=SMD,"RAND"=RAND,
"SOPHCR1" = SOPHCR1, "SOPHCR2" = SOPHCR2,
"SOPHCR3" = SOPHCR3, "SOPHCR4" = SOPHCR4, "SOPHCR5" = SOPHCR5, "SOPHCR6" = SOPHCR6, "SOPHMD1" = SOPHMD1, "SOPHMD2" = SOPHMD2,
"SOPHMD3" = SOPHMD3, "SOPHMD4" = SOPHMD4,"SOPHMD5" = SOPHMD5, "SOPHMD6" = SOPHMD6,"SOPHMD7" = SOPHMD7, "SOPHMD8" = SOPHMD8,
"SOPHMD9" = SOPHMD9, "SOPHMD10" = SOPHMD10, "SSOPHCR" = SSOPHCR, "SSOPHMD" = SSOPHMD)

```

As MLFIT uses all data from one experimental set (in our case 10
experimental groups of 6 players - making a total of 60 players), we
need to form our new data set.

```{r}
# Here the base values are going to be number_of_experimental_groups = 10 and size_of_experimental_group = 6, simulation number shows us which simulation we're looking at (the first 60 players, players having id of 60-120, players having id of 120-180, etc)
make_simulations_MLFIT <- function(number_of_experimental_groups = 10, size_of_experimental_group = 6, simulation_number){
  
  simulations <- list()
  first_experimental_group <- number_of_experimental_groups*(simulation_number - 1) + 1
  last_experimental_group <- first_experimental_group + number_of_experimental_groups - 1
  for (i in first_experimental_group:last_experimental_group){
    simulations[[i]] <- simulation_list[[i]]
  }
  for (i in 1:length(simulations)) {
    simulations[[i]]$player1_id <- simulations[[i]]$player1_id + size_of_experimental_group * (i - 1)
    simulations[[i]]$player2_id <- simulations[[i]]$player2_id + size_of_experimental_group * (i - 1)

  }
  simulations_MLFIT <- do.call(rbind, simulations)

  return(simulations_MLFIT)
}

```

We form our estimation method:

```{r}
MLFIT_classifier <- function(number_of_experimental_groups = 10, size_of_experimental_group = 6, simulation_number){
  
  # used for testing
  # number_of_experimental_groups <- 10 
  # size_of_experimental_group <- 6 
  # simulation_number <- 1
  
  simulations <- make_simulations_MLFIT(number_of_experimental_groups, size_of_experimental_group, simulation_number)

  # We set game = 1 for the stratEst.data function
  simulations$game <- 1
  
  # Creating a new data frame for all players and their substrategies and strategies
  unique_players <- unique(simulations[, c("player1_id","player1_substrategy")])
  unique_players$player1_strategy <- sapply(unique_players$player1_substrategy, get_strategy)
  
  # Sorting the players
  unique_players <- unique_players[order(unique_players$player1_id), ]
  colnames(unique_players)[colnames(unique_players) == "player1_id"] <- "player_id"
  
  # We obtain the stratEst dataset used later in the model
  data.hr <- stratEst.data(data = simulations, choice = "player1_action_played",input = c("player1_history_sum","player2_history_sum"),id = "player1_id", game = "game", period = "round")

  # Running the model
  modelhr<-stratEst.model(data = data.hr, strategies = strathr, select="strategies", crit="aic")

  # Above we add select="strategies" and crit="aic" which chooses only best fit strategies from strathr according to aic criterion
  shares <- modelhr$shares
  types <- data.frame(modelhr$post.assignment)

  # We apply the get_strategy function to convert the substrategies to strategies
  new_colnames <- sapply(colnames(types), get_strategy)
  colnames(types) <- new_colnames

  # Function to sum columns with same names
  sum_duplicate_columns <- function(df) {
    # Get unique column names
    unique_names <- unique(names(df))
    # Initialize an empty data frame to store the results
    result_df <- data.frame(matrix(ncol = length(unique_names), nrow = nrow(df)))
    colnames(result_df) <- unique_names
    # Loop through unique column names
    for (name in unique_names) {
      # Find columns with the same name
      cols <- grep(name, names(df))
      # Sum the values in those columns
      result_df[[name]] <- rowSums(df[, cols, drop = FALSE])
    }
    return(result_df)
  }
  
  # Call the function to sum columns with same names
  summarized_df <- sum_duplicate_columns(types)  
  
  # Adding a new column for the maximum probability
  typesFinal<-cbind(summarized_df,colnames(summarized_df)[max.col(summarized_df)])
  
  col_names <- names(typesFinal)
  col_names[length(typesFinal)] <- "TYPE"
  names(typesFinal) <- col_names
  
  typesFinal$max <- apply(typesFinal[,1:ncol(typesFinal)-1], 1, max, na.rm=TRUE)

  for (i in 1:nrow(typesFinal)){
  if (typesFinal$max[i]>0.5 && (typesFinal$TYPE[i])!="RAND"){
    typesFinal$Final[i]<-typesFinal$TYPE[i]
  }else{
    typesFinal$Final[i]<-"UCL"
    }
  }
  unique_players
  
  first_player_id <- min(unique_players$player_id)
  last_player_id <- max(unique_players$player_id)
  
  # Adding a player_id column
  typesFinal$player_id <- first_player_id:last_player_id
  
  # Moving the new column to the first position
  typesFinal <- typesFinal[, c(ncol(typesFinal), 1:(ncol(typesFinal)-1))]
  
  # Adding the predetermined strategy in the data frame for easier comparison
  typesFinal <- merge(typesFinal, unique_players[, c("player_id", "player1_substrategy", "player1_strategy")], by = "player_id", all.x = TRUE)

  # Creating a new column to check if TYPE matches strategy
  typesFinal$match <- typesFinal$TYPE == typesFinal$player1_strategy
  
  # Adding up the number of matches
  num_matching_strategies <- sum(typesFinal$match)
  
  # This is going to be the output of this function, alongside the data frame of the types
  stats_table <- data.frame(
                          num_matching_strategies = num_matching_strategies
  )
  
  return(list(typesFinal, stats_table))
}

```


## Statistical tests of estimation methods

### Accuracy analysis

First of all, we make a new data frame consisting of all players in all
of our simulations and their evaluated strategies by each estimation method.

```{r}
predictions_df <- function(number_of_experimental_groups, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6){
  start_time <- Sys.time()
  # Initializing empty lists to store data frames
  df_DFIT <- list()
  df_SFIT <- list()
  df_TREND <- list()
  df_MLFIT <- list()
   
  amount_of_simulations <- number_of_experimental_groups/number_of_experimental_groups_MLFIT
 
  # Loop over the range of the amount of MLFIT simulations
  for (i in 1:amount_of_simulations) {
    print(paste("Doing MLFIT number",i))
    df_MLFIT[i] <- MLFIT_classifier(number_of_experimental_groups_MLFIT, size_of_experimental_group, i)[1]
    df_MLFIT[[i]] <- df_MLFIT[[i]][, c("player_id", "player1_substrategy", "player1_strategy", "Final")]
  }
  
  # Loop over the range of the amount of DFIT, SFIT and TREND classifications
  for (i in 1:number_of_experimental_groups){
    print(paste("Doing DFIT, SFIT, TREND number",i))
    df_DFIT[i] <- DFIT_classifier(simulation_list[[i]])[1]
    df_SFIT[i] <- SFIT_classifier(simulation_list[[i]])[1]
    df_TREND[i] <- TREND_classifier(simulation_list[[i]])[1]
  } 
  
  # Combine all data by rows
  combined_MLFIT_data <- do.call(rbind, df_MLFIT)
  combined_DFIT_data <- do.call(rbind, df_DFIT)
  combined_SFIT_data <- do.call(rbind, df_SFIT)
  combined_TREND_data <- do.call(rbind, df_TREND)

  final_data <- combined_MLFIT_data
  # Rename the Final column to MLFIT
  names(final_data)[names(final_data) == "Final"] <- "MLFIT_classification"
  names(final_data)[names(final_data) == "player1_strategy"] <- "sender_strategy_MLFIT_DFIT"

  first_player_id <- 1
  last_player_id <- number_of_experimental_groups*size_of_experimental_group

  # Adding a player_id column
  combined_DFIT_data$player_id <- first_player_id:last_player_id
  combined_SFIT_data$player_id <- first_player_id:last_player_id
  combined_TREND_data$player_id <- first_player_id:last_player_id
  
  # Moving the new column to the first position
  combined_DFIT_data <- combined_DFIT_data[, c(ncol(combined_DFIT_data), 1:(ncol(combined_DFIT_data)-1))]
  combined_DFIT_data <- subset(combined_DFIT_data, select = -2)
  combined_SFIT_data <- combined_SFIT_data[, c(ncol(combined_SFIT_data), 1:(ncol(combined_SFIT_data)-1))]
  combined_SFIT_data <- subset(combined_SFIT_data, select = -2)
  combined_TREND_data <- combined_TREND_data[, c(ncol(combined_TREND_data), 1:(ncol(combined_TREND_data)-1))]
  combined_TREND_data <- subset(combined_TREND_data, select = -2)

  # Adding all data to one data frame and changing names
  final_data <- merge(final_data, combined_DFIT_data[, c("player_id", "player1_predicted_strategy")], by = "player_id", all.x = TRUE)
  names(final_data)[names(final_data) == "player1_predicted_strategy"] <- "DFIT_classification"
  
  final_data <- merge(final_data, combined_SFIT_data[, c("player_id", "player1_strategy", "player1_predicted_strategy")], by = "player_id", all.x = TRUE)
  names(final_data)[names(final_data) == "player1_predicted_strategy"] <- "SFIT_classification"
  names(final_data)[names(final_data) == "player1_strategy"] <- "sender_strategy_SFIT"
  
  final_data <- merge(final_data, combined_TREND_data[, c("player_id", "player1_strategy", "player1_predicted_strategy", "helping_rate")], by = "player_id", all.x = TRUE)
  names(final_data)[names(final_data) == "player1_predicted_strategy"] <- "TREND_classification"
  names(final_data)[names(final_data) == "player1_strategy"] <- "sender_strategy_TREND"
  names(final_data)[names(final_data) == "player1_substrategy"] <- "sender_substrategy"

  end_time <- Sys.time()
  runtime <- end_time - start_time
  print(runtime)
  return(final_data)
}

# predict <- predictions_df(number_of_experimental_groups = 10, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6)
# predict

```

We save our data in data frames:
```{r}
# TEST TEST

# # simulating the data
num_simulations <- 10 # we will do 2000 in our research
num_players <- 6
num_rounds <- 100
sender_payoff <- 150
receiver_payoff <- 250
starting_money <- 3000
error_rate <- 0.1

first_substrategy_probabilities <- c(ALT = 7/54, #7/54
                            DEF = 12/54, #12/54
                            REW1 = 6/54, #14/54 /# of all REW substr
                            REW2 = 0,
                            REW3 = 1/54,
                            SREW = 7/54,
                            CAU0 = 0, #1/54 /# of all CAU substr
                            CAU1 = 0,
                            SCAU = 1/54,
                            CR10 = 0, #5/54 /# of all CR substr
                            CR11 = 0,
                            CR20 = 0,
                            CR21 = 0,
                            CR30 = 0,
                            CR31 = 0,
                            SCR = 5/54,
                            MD10 = 1/54, #4/54 /# of all MD substr
                            MD11 = 0,
                            MD20 = 0,
                            MD21 = 0,
                            MD30 = 0,
                            MD31 = 0,
                            SMD = 2/54,
                            SophCR1 = 0,
                            SophCR2 = 0,
                            SophCR3 = 0,
                            SophCR4 = 0,
                            SophCR5 = 0,
                            SophCR6 = 0,
                            SSophCR = 0,
                            SophMD1 = 0,
                            SophMD2 = 0,
                            SophMD3 = 0,
                            SophMD4 = 0,
                            SophMD5 = 0,
                            SophMD6 = 0,
                            SophMD7 = 0,
                            SophMD8 = 0,
                            SophMD9 = 1/54,
                            SophMD10 = 0,
                            SSophMD = 0,
                            POI = 11/(54*5*3), #11/54 /5 for all PO substr
                            POH = 11/(54*5*3),
                            POL = 11/(54*5*3),
                            RAND = 11/(54*5), #11/54 /5 for RAND substr
                            EXP31 = 11/(54*5*4), #11/54 /5 for all EXP substr
                            EXP32 = 11/(54*5*4),
                            EXP33 = 11/(54*5*4),
                            EXP3S = 11/(54*5*4),
                            ALTERNATE = 11/(54*5), #11/54 /5 for ALTERNATE substr
                            EX1 = 11/(54*5)) #11/54 /5 for memory-1 experiential substr

simulation_list <- simulate_data(num_simulations, num_players, num_rounds, substrategy_probabilities = first_substrategy_probabilities, sender_payoff, receiver_payoff, starting_money, error_rate)
test_predict_0.05_first <- predictions_df(number_of_experimental_groups = num_simulations, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6)

```


```{r} 
# # simulating the data
# num_simulations <- 2000 # we will do 2000 in our research
# num_players <- 6
# num_rounds <- 100
# sender_payoff <- 150
# receiver_payoff <- 250
# starting_money <- 3000
# 
# # first distribution
# # Defining substrategy probabilities
# first_substrategy_probabilities <- c(ALT = 7/54, #7/54
#                             DEF = 12/54, #12/54
#                             REW1 = 6/54, #14/54 /# of all REW substr
#                             REW2 = 0,
#                             REW3 = 1/54,
#                             SREW = 7/54,
#                             CAU0 = 0, #1/54 /# of all CAU substr
#                             CAU1 = 0,
#                             SCAU = 1/54,
#                             CR10 = 0, #5/54 /# of all CR substr
#                             CR11 = 0,
#                             CR20 = 0,
#                             CR21 = 0,
#                             CR30 = 0,
#                             CR31 = 0,
#                             SCR = 5/54,
#                             MD10 = 1/54, #4/54 /# of all MD substr
#                             MD11 = 0,
#                             MD20 = 0,
#                             MD21 = 0,
#                             MD30 = 0,
#                             MD31 = 0,
#                             SMD = 2/54,
#                             SophCR1 = 0,
#                             SophCR2 = 0,
#                             SophCR3 = 0,
#                             SophCR4 = 0,
#                             SophCR5 = 0,
#                             SophCR6 = 0,
#                             SSophCR = 0,
#                             SophMD1 = 0,
#                             SophMD2 = 0,
#                             SophMD3 = 0,
#                             SophMD4 = 0,
#                             SophMD5 = 0,
#                             SophMD6 = 0,
#                             SophMD7 = 0,
#                             SophMD8 = 0,
#                             SophMD9 = 1/54,
#                             SophMD10 = 0,
#                             SSophMD = 0,
#                             POI = 11/(54*4*3), #11/54 /4 for all PO substr
#                             POH = 11/(54*4*3),
#                             POL = 11/(54*4*3),
#                             RAND = 11/(54*4), #11/54 /4 for RAND substr
#                             EXP31 = 11/(54*4*5), #11/54 /4 for all EXP substr
#                             EXP32 = 11/(54*4*5),
#                             EXP33 = 11/(54*4*5),
#                             EXP3S = 11/(54*4*5),
#                             ALTERNATE = 11/(54*4), #11/54 /4 for ALTERNATE substr
#                             EX1 = 11/(54*4*5))
# 
first_substrategy_probabilities <- c(ALT = 7/54, #7/54
                            DEF = 12/54, #12/54
                            REW1 = 6/54, #14/54 /# of all REW substr
                            REW2 = 0,
                            REW3 = 1/54,
                            SREW = 7/54,
                            CAU0 = 0, #1/54 /# of all CAU substr
                            CAU1 = 0,
                            SCAU = 1/54,
                            CR10 = 0, #5/54 /# of all CR substr
                            CR11 = 0,
                            CR20 = 0,
                            CR21 = 0,
                            CR30 = 0,
                            CR31 = 0,
                            SCR = 5/54,
                            MD10 = 1/54, #4/54 /# of all MD substr
                            MD11 = 0,
                            MD20 = 0,
                            MD21 = 0,
                            MD30 = 0,
                            MD31 = 0,
                            SMD = 2/54,
                            SophCR1 = 0,
                            SophCR2 = 0,
                            SophCR3 = 0,
                            SophCR4 = 0,
                            SophCR5 = 0,
                            SophCR6 = 0,
                            SSophCR = 0,
                            SophMD1 = 0,
                            SophMD2 = 0,
                            SophMD3 = 0,
                            SophMD4 = 0,
                            SophMD5 = 0,
                            SophMD6 = 0,
                            SophMD7 = 0,
                            SophMD8 = 0,
                            SophMD9 = 1/54,
                            SophMD10 = 0,
                            SSophMD = 0,
                            POI = 11/(54*5*3), #11/54 /5 for all PO substr
                            POH = 11/(54*5*3),
                            POL = 11/(54*5*3),
                            RAND = 11/(54*5), #11/54 /5 for RAND substr
                            EXP31 = 11/(54*5*4), #11/54 /5 for all EXP substr
                            EXP32 = 11/(54*5*4),
                            EXP33 = 11/(54*5*4),
                            EXP3S = 11/(54*5*4),
                            ALTERNATE = 11/(54*5), #11/54 /5 for ALTERNATE substr
                            EX1 = 11/(54*5)) #11/54 /5 for memory-1 experiential substr
# 
# # simulations, comment out to not run all simulations
# for (error_rate in c(0.05,0.1,0.15)){
#   if (error_rate == 0.05) {
#       simulation_list <- simulate_data(num_simulations, num_players, num_rounds, substrategy_probabilities = first_substrategy_probabilities, sender_payoff, receiver_payoff, starting_money, error_rate)
#       predict_0.05_first <- predictions_df(number_of_experimental_groups = num_simulations, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6)
#       write.csv(predict_0.05_first,"~/Downloads/predict_0.05_first.csv", row.names = FALSE)
#     } else if(error_rate == 0.1) {
#       simulation_list <- simulate_data(num_simulations, num_players, num_rounds, substrategy_probabilities = first_substrategy_probabilities, sender_payoff, receiver_payoff, starting_money, error_rate)
#       predict_0.1_first <- predictions_df(number_of_experimental_groups = num_simulations, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6)
#       write.csv(predict_0.1_first,"~/Downloads/predict_0.1_first.csv", row.names = FALSE)
#     } else if (error_rate == 0.15) {
#       simulation_list <- simulate_data(num_simulations, num_players, num_rounds, substrategy_probabilities = first_substrategy_probabilities, sender_payoff, receiver_payoff, starting_money, error_rate)
#       predict_0.15_first <- predictions_df(number_of_experimental_groups = num_simulations, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6)
#       write.csv(predict_0.15_first,"~/Downloads/predict_0.15_first.csv", row.names = FALSE)
#     }
# }
# 
# # second distribution
# # second_substrategy_probabilities <- c(ALT = 7/54, #7/54 
# #                             DEF = 12/54, #12/54
# #                             REW1 = 14/(4*54), #14/54 /# of all REW substr
# #                             REW2 = 14/(4*54), 
# #                             REW3 = 14/(4*54),
# #                             SREW = 14/(4*54),
# #                             CAU0 = 1/(3*54), #1/54 /# of all CAU substr
# #                             CAU1 = 1/(3*54),
# #                             SCAU = 1/(3*54),
# #                             CR10 = 5/(14*54), #5/54 /# of all CR substr
# #                             CR11 = 5/(14*54),
# #                             CR20 = 5/(14*54),
# #                             CR21 = 5/(14*54),
# #                             CR30 = 5/(14*54),
# #                             CR31 = 5/(14*54),
# #                             SCR = 5/(14*54),
# #                             MD10 = 4/(18*54), #4/54 /# of all MD substr
# #                             MD11 = 4/(18*54),
# #                             MD20 = 4/(18*54),
# #                             MD21 = 4/(18*54),
# #                             MD30 = 4/(18*54),
# #                             MD31 = 4/(18*54),
# #                             SMD = 4/(18*54),
# #                             SophCR1 = 5/(14*54),
# #                             SophCR2 = 5/(14*54),
# #                             SophCR3 = 5/(14*54),
# #                             SophCR4 = 5/(14*54),
# #                             SophCR5 = 5/(14*54),
# #                             SophCR6 = 5/(14*54),  
# #                             SSophCR = 5/(14*54), 
# #                             SophMD1 = 4/(18*54),
# #                             SophMD2 = 4/(18*54),
# #                             SophMD3 = 4/(18*54),
# #                             SophMD4 = 4/(18*54),
# #                             SophMD5 = 4/(18*54),
# #                             SophMD6 = 4/(18*54), 
# #                             SophMD7 = 4/(18*54),
# #                             SophMD8 = 4/(18*54),
# #                             SophMD9 = 4/(18*54),
# #                             SophMD10 = 4/(18*54),
# #                             SSophMD = 4/(18*54),
# #                             POI = 11/(54*4*3), #11/54 /4 for all PO substr
# #                             POH = 11/(54*4*3),
# #                             POL = 11/(54*4*3),
# #                             RAND = 11/(54*4), #11/54 /4 for RAND substr
# #                             EXP31 = 11/(54*4*5), #11/54 /4 for all EXP substr
# #                             EXP32 = 11/(54*4*5),
# #                             EXP33 = 11/(54*4*5),
# #                             EXP3S = 11/(54*4*5),
# #                             ALTERNATE = 11/(54*4), #11/54 /4 for ALTERNATE substr
# #                             EX1 = 11/(54*4*5))
# 
second_substrategy_probabilities <- c(ALT = 7/54, #7/54
                            DEF = 12/54, #12/54
                            REW1 = 14/(4*54), #14/54 /# of all REW substr
                            REW2 = 14/(4*54),
                            REW3 = 14/(4*54),
                            SREW = 14/(4*54),
                            CAU0 = 1/(3*54), #1/54 /# of all CAU substr
                            CAU1 = 1/(3*54),
                            SCAU = 1/(3*54),
                            CR10 = 5/(14*54), #5/54 /# of all CR substr
                            CR11 = 5/(14*54),
                            CR20 = 5/(14*54),
                            CR21 = 5/(14*54),
                            CR30 = 5/(14*54),
                            CR31 = 5/(14*54),
                            SCR = 5/(14*54),
                            MD10 = 4/(18*54), #4/54 /# of all MD substr
                            MD11 = 4/(18*54),
                            MD20 = 4/(18*54),
                            MD21 = 4/(18*54),
                            MD30 = 4/(18*54),
                            MD31 = 4/(18*54),
                            SMD = 4/(18*54),
                            SophCR1 = 5/(14*54),
                            SophCR2 = 5/(14*54),
                            SophCR3 = 5/(14*54),
                            SophCR4 = 5/(14*54),
                            SophCR5 = 5/(14*54),
                            SophCR6 = 5/(14*54),
                            SSophCR = 5/(14*54),
                            SophMD1 = 4/(18*54),
                            SophMD2 = 4/(18*54),
                            SophMD3 = 4/(18*54),
                            SophMD4 = 4/(18*54),
                            SophMD5 = 4/(18*54),
                            SophMD6 = 4/(18*54),
                            SophMD7 = 4/(18*54),
                            SophMD8 = 4/(18*54),
                            SophMD9 = 4/(18*54),
                            SophMD10 = 4/(18*54),
                            SSophMD = 4/(18*54),
                            POI = 11/(54*5*3), #11/54 /5 for all PO substr
                            POH = 11/(54*5*3),
                            POL = 11/(54*5*3),
                            RAND = 11/(54*5), #11/54 /5 for RAND substr
                            EXP31 = 11/(54*5*4), #11/54 /5 for all EXP substr
                            EXP32 = 11/(54*5*4),
                            EXP33 = 11/(54*5*4),
                            EXP3S = 11/(54*5*4),
                            ALTERNATE = 11/(54*5), #11/54 /5 for ALTERNATE substr
                            EX1 = 11/(54*5)) #11/54 /5 for memory-1 experiential substr
# 
# # simulations
# for (error_rate in c(0.05, 0.1, 0.15)){
#   if (error_rate == 0.05) {
#       simulation_list <- simulate_data(num_simulations, num_players, num_rounds, substrategy_probabilities = second_substrategy_probabilities, sender_payoff, receiver_payoff, starting_money, error_rate)
#       predict_0.05_second <- predictions_df(number_of_experimental_groups = num_simulations, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6)
#       write.csv(predict_0.05_second,"~/Downloads/predict_0.05_second.csv", row.names = FALSE)
#     } else if(error_rate == 0.1) {
#       simulation_list <- simulate_data(num_simulations, num_players, num_rounds, substrategy_probabilities = second_substrategy_probabilities, sender_payoff, receiver_payoff, starting_money, error_rate)
#       predict_0.1_second <- predictions_df(number_of_experimental_groups = num_simulations, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6)
#       write.csv(predict_0.1_second,"~/Downloads/predict_0.1_second.csv", row.names = FALSE)
#     } else if (error_rate == 0.15) {
#       simulation_list <- simulate_data(num_simulations, num_players, num_rounds, substrategy_probabilities = second_substrategy_probabilities, sender_payoff, receiver_payoff, starting_money, error_rate)
#       predict_0.15_second <- predictions_df(number_of_experimental_groups = num_simulations, number_of_experimental_groups_MLFIT = 10, size_of_experimental_group = 6)
#       write.csv(predict_0.15_second,"~/Downloads/predict_0.15_second.csv", row.names = FALSE)
#     }
# }


```

We save all the data frames in the Downloads folder. The data frames are:

```{r}
# We load the data sets from the simulations
first_0.05 <- read.csv("~/Downloads/predict_0.05_first.csv", header=TRUE)
first_0.1 <- read.csv("~/Downloads/predict_0.1_first.csv", header=TRUE)
first_0.15 <- read.csv("~/Downloads/predict_0.15_first.csv", header=TRUE)

second_0.05 <- read.csv("~/Downloads/predict_0.05_second.csv", header=TRUE)
second_0.1 <- read.csv("~/Downloads/predict_0.1_second.csv", header=TRUE)
second_0.15 <- read.csv("~/Downloads/predict_0.15_second.csv", header=TRUE)

```
